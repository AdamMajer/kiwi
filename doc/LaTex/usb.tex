\index{KIWI images!usb|(}
\chapter{USB image - Live-Stick System}
\label{chapter:usb}
\minitoc

A live USB stick image is a system on USB stick which allows you to
boot and run from this device without using any other storage device of
the computer. It is urgently required that the BIOS of the system which
you plug the stick in supports booting from USB stick. Almost all
new BIOS systems support that. The USB stick serves as OS system disk
in this case and you can read and write data onto it.

\section{Building the suse-live-stick example}

The latest example provided with kiwi is based on openSUSE 11.0 and makes use
of the default plus x11 pattern. The operating system is stored on a
standard ext3 filesystem. 

\begin{Command}{12cm}
\begin{verbatim}
cd /usr/share/doc/packages/kiwi/examples
cd suse-11.0
kiwi --prepare ./suse-live-stick \
     --root /tmp/mystick
\end{verbatim}
\end{Command}

There are two possible image types which allows you to drive the
stick. Both are added into the config.xml of this example image
description. If you already have access to the stick you want to
run the image on the first approach should be preferred over the
second one.

\begin{itemize}
\item The first image type named ''usb'' creates all required
      images for booting the OS but requires you to plug in the stick
      and let kiwi deploy the data onto this stick.

      \begin{Command}{12cm}
      \begin{verbatim}
kiwi --create /tmp/mystick --type usb \
     -d /tmp/mystick-result
      \end{verbatim}
      \end{Command}

\item The second image type named ''oem'' allows you to create a
      virtual disk which represents a virtual disk geometry including
      all partitions and boot information in one file. You simply can ''dd''
      this file on the stick.

      \begin{Command}{12cm}
      \begin{verbatim}
kiwi --create /tmp/mystick --type oem \
     -d /tmp/mystick-result
      \end{verbatim}
      \end{Command}
\end{itemize}

\section{Using the image}

To make use of the created images they need to be deployed on the
USB stick. For the first image type (usb) you need kiwi itself to
be able to deploy the image on the stick. The reason for this is
that the usb image type has created the boot and the system image
but there is no disk geometry or partition table available. kiwi
creates a new partition table on the stick and imports the created
images as follows:

\begin{Command}{13cm}
\begin{verbatim}
kiwi --bootstick \
   /tmp/mystick-result/\
   initrd-usbboot-suse-11.0.i686-2.1.1.splash.gz \
   --bootstick-system \
   /tmp/mystick-result/\
   suse-11.0-live-stick.i686-1.1.2
\end{verbatim}
\end{Command}

In case of the second image type (oem) you only need a tool which allows
you to dump data onto a device. On Linux the most popular tool to do this
is the \textbf{dd} command. The oem image is represented by the file
with the .raw extension. As said this is a virtual disk which already
includes partition information. But this partition information does
not match the real USB stick geometry which means the kiwi boot image
(oemboot) has to adapt the disk geometry on first boot. To deploy the
image on the stick call:

\begin{Command}{13cm}
\begin{verbatim}
dd if=/tmp/mystick-result/\
   suse-11.0-live-stick.i686-1.1.2.raw \
   of=/dev/<stick-device> bs=32k
\end{verbatim}
\end{Command}

Testing of the live stick can be done with a test machine which boots from
USB or with a virtualisation system. If you test with a virtualisation
system for example qemu you should be aware that the USB stick looks like
a normal disk to the system. The kiwi boot process searches for the USB
stick to be able to mount the correct storage device but in a virtual
environment the disk doesn't appear as a USB stick. So if your
virtualisation solution doesn't provide a virtual BIOS which allows booting
from USB stick you should test the stick on real hardware

\section{Flavours}

USB sticks weren't designed to serve as storage devices for
operating systems. By design of these nice little gadgets their
storage capacity is limited to only a few G-bytes. According to
this KIWI supports compressed filesystems with USB sticks too:  

\begin{itemize}
\item \textbf{filesystem=''squashfs''}\\
      This will compress the image using the squashfs filesystem. The
      boot process will automatically use aufs as overlay filesystem to
      mount the complete tree read-write. For the write part an additional
      ext2 partition will be created on the stick. The support for this
      compression layer requires squashfs and aufs to be present in
      the distribution KIWI has used to build the image 
\item \textbf{filesystem=''dmsquash''}\\
      Creates an ext3 image file and puts that
      into a squashfs filesystem. On boot the root tree is mounted
      via a device mapper snapshot device to allow full write
      access over the complete tree.
\item \textbf{filesystem=''clicfs''}\\
      Creates a fuse based clicfs image and allows write operations
      into a cow file.
\end{itemize}

\subsection{Split stick}
If there is no overlay filesystem available it is also possible to
define a split section in config.xml and use the split support to
split the image into a compressed read-only and a read-write portion.
To create a split stick the types needs to be adapted as follows:

\begin{itemize}
\item \textbf{type setup for split usb type:}

      \begin{Command}{12cm}
      \begin{verbatim}
<type fsreadwrite="ext3" fsreadonly="squashfs"
      boot="usbboot/suse-11.0">split</type>
      \end{verbatim}
      \end{Command}
\item \textbf{type setup for split oem type:}

      \begin{Command}{12cm}
      \begin{verbatim}
<type fsreadwrite="ext3" fsreadonly="squashfs"
      boot="oemboot/suse-11.0">split</type>
      \end{verbatim}
      \end{Command}
\end{itemize}

For both types a split section is required which defines the read-write
data. A good starting point is to set /var, /home and /etc as writable
data.

\begin{Command}{12cm}
\begin{verbatim}
<split>
   <persistent>
      <!-- allow read/write access to: -->
      <file name="/var"/>
      <file name="/var/*"/>
      <file name="/etc"/>
      <file name="/etc/*"/>
      <file name="/home"/>
      <file name="/home/*"/>
   </persistent>
</split>
\end{verbatim}
\end{Command}

If no split section is added the default split section from
/usr/share/kiwi/modules/KIWISplit.txt is used

\subsection{LVM support}

kiwi also provides support for LVM (Logical Volume Management). In this
mode the disk partition table will include one lvm partition and one
standard ext2 boot partition. kiwi creates the kiwiVG volume group and
adds logical volumes as they are needed and configured according to the
image type and filesystem. After boot of the system the user has full
control over the volume group and is free to change/resize/increas the
group and the volumes inside. Support for LVM has been added for all
image types which are disk based. This includes vmx,oem and usb.
In order to use LVM for the usb type just add the \verb+--lvm+ option
as part of the kiwi \verb+kiwi --bootstick+ deployment or add the
attribute \textbf{lvm=''true''} as part of the \textbf{type} section
in your config.xml file.

The optional \textbf{lvmvolumes} section can be used to set one or
more top level directories into a separate volume. For example you
want to put /usr and /var into different volumes add the following
lvmvolumes section:

\begin{Command}{12cm}
\begin{verbatim}
<lvmvolumes>
   <volume name="usr" freespace="100M"/>
   <volume name="var" size="200M"/>
</lvmvolumes>
\end{verbatim}
\end{Command}

The optional freespace attribute let you add additional free space
for that volume. If you don't set any freespace the volume will be
about 80\% to 90\% full. The optional size attribute let you specify
the absolute size for that volume. If both freespace and size are set
size is preferred. If the given size is too small the value will be
ignored.
