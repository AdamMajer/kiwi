\index{KIWI images!oem|(}
\chapter{OEM image - Preload Systems}
\label{chapter:oem}
\minitoc

An oem image is a virtual disk image representing all partitions
and bootloader information like it exists on a real disk. The image
format is the same compared to the VMX image type. All flavours
explained in the VMX chapter also applies to the OEM type.

The original idea of an oem image is to provide this virtual disk data
to OEM vendors which now are able to deploy the system independently onto
their storage media. The deployment can happen from any OS including
Windows if a tool to dump data on a disk device exists. The oem image
type is also used to deploy images on USB sticks because in principal
it is the same workflow.

\section{Building the suse-oem-preload example}

The latest example provided with kiwi is based on openSUSE 11.0 and includes
the patterns default plus x11. The image type is a split type whereas
the read-write filesystem is ext3 and the read-only filesystem is
squashfs. The additional format attribute also creates an installable
ISO image for deploying the image from CD. 

\begin{Command}{12cm}
\begin{verbatim}
cd /usr/share/doc/packages/kiwi/examples
cd suse-11.0
kiwi --prepare ./suse-oem-preload \
     --root /tmp/myoem
\end{verbatim}
\end{Command}

\begin{Command}{12cm}
\begin{verbatim}
kiwi --create /tmp/myoem --type split \
     -d /tmp/myoem-result
\end{verbatim}
\end{Command}

\section{Using the image}

Testing the oem virtual disk can be done with a virtualisation software
like QEMU or VMware. The virtual disk is represented by the .raw extension
whereas the .iso extension represents the installation disk for this oem
image. The installation disk should be tested on a bare test system
For the .raw test just call:

\begin{Command}{12cm}
\begin{verbatim}
cd /tmp/myoem-result
qemu suse-11.0-oem-preload.i686-1.1.2.raw \
     -m 512
\end{verbatim}
\end{Command}

or dump the image on a test hard disk and select it as boot device
in the BIOS:

\begin{Command}{12cm}
\begin{verbatim}
cd /tmp/myoem-result
dd if=suse-11.0-oem-preload.i686-1.1.2.raw \
   of=/dev/<device> bs=32k
\end{verbatim}
\end{Command}

Please note if you test an oem image the virtual disk geometry of the
image is the same as the disk geometry inside the host system. According
to this the oem boot workflow will skip the re-partitioning which is
performed if there would be a real disk

\section{Flavours}

An interesting part of an oem image is that it can be turned into
an installation image too. This means it is possible to create an
installation CD / DVD or USB stick which deploysthe oem based
image onto the selected storage device. The installation process
is a simply dd of the image onto the selected device so don't
expect any user interaction or GUI here to pop up. KIWI supports
two types of installation media:

\begin{itemize}
\item <type ... format=''iso''>...</type>\\
      Creates a .iso file which can be burned in CD or DVD. This
      represents an installation CD
\item <type ... format=''usb''>...</type>\\
      Creates a .raw.install file which can be dumped (dd) on a
      USB stick. This represents an installation Stick
\end{itemize}

\subsection{Influencing the oem partitioning}

By default the oemboot process will create/modify a swap, /home and /
partition. It is possible to influence the behavior by the following
oem-* elements which can be optionally specified within the
\textbf{preferences} section of your system image XML description.
KIWI uses this to create the file \textbf{/config.oempartition} as part
of the automatically created oemboot boot image. The format of the
file is a simple key=value format and created by the KIWIConfig.sh
function named baseSetupOEMPartition. Following oem-* elements can
be specified:

\begin{itemize}
\item \textbf{<oem-reboot>true|false</oem-reboot>}\\
      This allows to reboot the oem system after initial deployment.
      This value is represented by the variable OEM\_REBOOT in
      config.oempartition
\item \textbf{<oem-swapsize>number in MB</oem-swapsize>}\\
      Set the size of the swap partition. This value is represented by
      variable OEM\_SWAPSIZE in config.oempartition
\item \textbf{<oem-systemsize>number in MB</oem-systemsize>}\\
      Set the size of the / partition. This value is represented by the
      variable OEM\_SYSTEMSIZE in config.oempartition
\item \textbf{<oem-home>true|false</oem-home>}\\
      Specify if a home partition should be create. This value is represented
      by the variable OEM\_WITHOUTHOME in config.oempartition.
\item \textbf{<oem-swap>true|false</oem-swap>}\\
      Specify if a spaw partition should be create. This value is represented 
      by the variable OEM\_WITHOUTSWAP in config.oempartition.
\item \textbf{<oem-boot-title>text</oem-boot-title>}\\
      By default the string \textbf{OEM} will be appended to the
      boot manager menu when KIWI creates the grub configuration during
      first deployment. The oem-boot-title value allows to set a custom
      name which is used instead of OEM. This value is represented
      by the variable OEM\_BOOT\_TITLE in config.oempartition.
\item \textbf{<oem-recovery>true|false</oem-recovery>}\\
      If this element is set to true KIWI will create a recovery archive
      from the prepared root tree. The archive will appear as
      \textit{/recovery.tar.bz2} within the initial image file. During
      first boot of the image a single recovery partition will be
      created and the recovery archive will be moved into that
      partition. An additional boot menu entry will be created which
      allows to restore the original root tree information. The
      user information on the /home partition or in the /home directory
      are not affected by that recovery process
\item \textbf{<oem-kiwi-initrd>true|false</oem-kiwi-initrd>}\\
      If this element is set to true the initial oemboot boot image (initrd)
      will \textbf{not} be replaced by the system (mkinitrd) created initrd.
      This option makes sense if the target storage device for the image
      is not a fixed disk but for example an USB stick. In that case it
      might be required to re-detect the storage location on first boot which
      is done as part of the oemboot boot image  
\end{itemize}

%If you plan to use a custom partition setup you also should consider
%to create a copy of the original oemboot boot image description. The following
%workflow should be used to integrate a custom config.oempartition:

%\begin{enumerate}
%\item Clone the used boot image description
%\begin{verbatim}
%cp -a /usr/share/kiwi/image/oemboot/suse-... \
%      /usr/share/kiwi/image/oemboot/suse-...-myoem
%\end{verbatim}
%\item Copy the config.oempartition file into the boot image description 
%\begin{verbatim}
%cp config.oempartition \
%   /usr/share/kiwi/image/oemboot/suse-...-myoem/root
%\end{verbatim}
%\item Sign your new boot image description
%\begin{verbatim}
%kiwi --createhash \
%     /usr/share/kiwi/image/oemboot/suse-...-myoem
%\end{verbatim}
%\item Make sure your system image use the new boot image
%\begin{verbatim}
%<type ... boot="oemboot/suse-...-myoem">...</type>
%\end{verbatim}
%\end{enumerate}

\subsection{LVM support}

kiwi also provides support for LVM (Logical Volume Management). In this
mode the disk partition table will include one lvm partition and one
standard ext2 boot partition. kiwi creates the kiwiVG volume group and
adds logical volumes as they are needed and configured according to the
image type and filesystem. After boot of the system the user has full
control over the volume group and is free to change/resize/increas the
group and the volumes inside. Support for LVM has been added for all
image types which are disk based. This includes vmx,oem and usb.
In order to use LVM for the oem type just add the \verb+--lvm+ option
as part of the kiwi create step or add the attribute \textbf{lvm=''true''}
as part of the \textbf{type} section in your config.xml file.

\begin{Command}{12cm}
\begin{verbatim}
kiwi --create /tmp/myoem --type oem \
     -d /tmp/myoem-result --lvm
\end{verbatim}
\end{Command}

With the optional \textbf{lvmvolumes} section you can set one or
more top level directories into a separate volume. For example you
want to put /usr and /var into different volumes add the following
lvmvolumes section:

\begin{Command}{12cm}
\begin{verbatim}
<lvmvolumes>
   <volume name="usr" freespace="100M"/>
   <volume name="var"/>
</lvmvolumes>
\end{verbatim}
\end{Command}

The optional freespace attribute let you add additional free space
for that volume. If you don't set any freespace the volume will be
about 80\% to 90\% full.
